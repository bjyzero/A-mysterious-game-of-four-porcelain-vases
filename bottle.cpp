// 2 2 2 3 -> 1 1 1 5 -> 0 0 0 7
// 0 2 2 2 可能的一条路线 -> 2 1 1 1 -> 1 0 0 3
// 0 2 2 2 可能的一条路线 -> 2 1 1 1 -> 4 0 0 0
// 1 3 3 4 可能的一条路线 -> 0 2 2 6 -> 2 1 1 5 -> 1 0 0 7
// 1 6 6 7 可能的一条路线 -> 0 5 5 9 -> 2 4 4 8 -> 1 3 3 10 -> 0 2 2 12 -> 2 1 1 11 -> 1 0 0 13
// 总结一下：这里我们发现一种规律 -> 反补，即在最大和最小之间不停地转换

// 然而，这个规律并不在下面的案例中适用
//  0 2 5 5 可能的一条路线 -> 2 1 4 4 -> 1 0 3 6 -> 0 2 2 5 -> 2 1 1 4 -> 1 0 0 6
//  0 2 5 5 可能的一条路线 -> 2 1 4 4 -> 4 0 3 3 -> 3 2 2 2 -> 5 1 1 1 -> 7 0 0 0
// 这时还只考虑了选择开始最小和最大的进行操作，其他情况呢? 暂时没有证明
// 那我们干脆不证明了，我们枚举选择哪一个瓷瓶是最终瓷瓶，再也不事先考虑哪个最优

// 假设枚举的是 A，剩下的三个是 B C D
// A与 B C D 的大小关系未知，但知道 B <= C <= D
//   A         , B, C        , D
//->A + 2B    , 0, C - B    , D - B (起始情况)
//->A + 2B - 1, 2, C - B - 1, D - B - 1
//->A + 2B + 1, 1, C - B - 2, D - B - 2
//->A + 2B + 3, 0, C - B - 3, D - B - 3 (此时需要 C - B >= 3 且 A + 2B >=1)
//->...
//->X, 0, 0, Y 或者 X, 0, 1, Y 或者 X, 0, 2, Y
// 但是如果我们 循环 时间复杂度不正确 ---->四个整数范围 0 <= 数 <= 2 * 10^9

// 我们优化这个过程，我们把每次 B = 0 出现时当成一轮，起始情况为 A, B=0, C, D
// 对于 A 而言，每一轮会加 3
// 对于 B 而言，起始是 0，结束也是 0
// 对于 C 而言，每一轮会减 3
// 对于 D 而言，不重要，因为 D 一定会大于等于 C
// 考虑每一轮能发生的条件，一定是 A >= 1, C >= 3
// 发现 A 每一轮都在增加，所以只要一开始 A >= 1, A 就能永远满足大于等于 0 的条件
// 而 C 每一轮减 3，直到 C <= 3,即 C = 0, 1, 2
// 于是轮数只与 C 有关，一共 t = C / 3 轮
// A -> A + 3t, B = 0, C -> C % 3, D -> Y,且 Y >= C
// 若此时 C = 0,直接结束，当前情况为 A + 3t
// 若此时 C = 1,此时为 A + 3t, 0, 1, Y 不管怎么操作，不能更优，当前情况为 A + 3t
//(模拟: A + 3t, 0, 1, Y -> A + 3t - 1, 2 , 0, Y - 1 -> A + 3t - 2, 1, 2, Y - 2 -> A + 3t, 0, 1 , Y - 3)
// 若此时 C = 2,此时为 A + 3t, 0, 1, Y -> A + 3t - 1, 2, 1, Y - 1 -> A + 3t + 1 , 1, 0, Y - 2,当前情况答案为 A + 3t + 1
#include <bits/stdc++.h>
using namespace std;

using ll = long long;

int main(void)
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    vector<ll> a(4);
    for (auto &x : a)
        cin >> x;
    sort(a.begin(), a.end());

    auto f = [&](const ll &ini_A, const ll &ini_B, const ll &ini_C)
    {
        ll A = ini_A + 2 * ini_B;
        ll B = 0;
        ll C = ini_C - ini_B;
        ll t = C / 3;
        if (A == 0)
            return 0ll;
        C %= 3;
        if (C == 0 || C == 1)
            return A + 3 * t;
        else
            return A + 3 * t + 1;
    };

    cout << max({f(a[0], a[1], a[2]),
                 f(a[1], a[0], a[2]),
                 f(a[2], a[0], a[1]),
                 f(a[3], a[0], a[1])})
         << '\n';
         
    return 0;
}